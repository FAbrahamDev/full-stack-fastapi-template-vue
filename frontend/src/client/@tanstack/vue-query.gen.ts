// This file is auto-generated by @hey-api/openapi-ts

import type { Options } from "@hey-api/client-axios";
import { queryOptions, type UseMutationOptions } from "@tanstack/vue-query";
import type {
  LoginAccessTokenData,
  LoginAccessTokenError,
  LoginAccessTokenResponse,
  LoginTestTokenData,
  LoginTestTokenError,
  LoginTestTokenResponse,
  LoginRecoverPasswordData,
  LoginRecoverPasswordError,
  LoginRecoverPasswordResponse,
  LoginResetPasswordData,
  LoginResetPasswordError,
  LoginResetPasswordResponse,
  LoginRecoverPasswordHtmlContentData,
  LoginRecoverPasswordHtmlContentError,
  LoginRecoverPasswordHtmlContentResponse,
  UsersReadUsersData,
  UsersCreateUserData,
  UsersCreateUserError,
  UsersCreateUserResponse,
  UsersDeleteUserMeData,
  UsersDeleteUserMeError,
  UsersDeleteUserMeResponse,
  UsersReadUserMeData,
  UsersUpdateUserMeData,
  UsersUpdateUserMeError,
  UsersUpdateUserMeResponse,
  UsersUpdatePasswordMeData,
  UsersUpdatePasswordMeError,
  UsersUpdatePasswordMeResponse,
  UsersRegisterUserData,
  UsersRegisterUserError,
  UsersRegisterUserResponse,
  UsersDeleteUserData,
  UsersDeleteUserError,
  UsersDeleteUserResponse,
  UsersReadUserByIdData,
  UsersUpdateUserData,
  UsersUpdateUserError,
  UsersUpdateUserResponse,
  UtilsTestEmailData,
  UtilsTestEmailError,
  UtilsTestEmailResponse,
  UtilsHealthCheckData,
  ItemsReadItemsData,
  ItemsCreateItemData,
  ItemsCreateItemError,
  ItemsCreateItemResponse,
  ItemsDeleteItemData,
  ItemsDeleteItemError,
  ItemsDeleteItemResponse,
  ItemsReadItemData,
  ItemsUpdateItemData,
  ItemsUpdateItemError,
  ItemsUpdateItemResponse,
  PrivateCreateUserData,
  PrivateCreateUserError,
  PrivateCreateUserResponse,
} from "@/client";
import type { AxiosError } from "axios";
import {
  LoginService,
  UsersService,
  UtilsService,
  ItemsService,
  PrivateService,
  client,
} from "../sdk.gen";

type QueryKey<TOptions extends Options> = [
  Pick<TOptions, "baseURL" | "body" | "headers" | "path" | "query"> & {
    _id: string;
    _infinite?: boolean;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
): QueryKey<TOptions>[0] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseURL: (options?.client ?? client).getConfig().baseURL,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return params;
};

export const loginAccessTokenQueryKey = (
  options: Options<LoginAccessTokenData>,
) => [createQueryKey("loginAccessToken", options)];

export const loginAccessTokenOptions = (
  options: Options<LoginAccessTokenData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await LoginService.loginAccessToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: loginAccessTokenQueryKey(options),
  });
};

export const loginAccessTokenMutation = (
  options?: Partial<Options<LoginAccessTokenData>>,
) => {
  const mutationOptions: UseMutationOptions<
    LoginAccessTokenResponse,
    AxiosError<LoginAccessTokenError>,
    Options<LoginAccessTokenData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await LoginService.loginAccessToken({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const loginTestTokenQueryKey = (
  options?: Options<LoginTestTokenData>,
) => [createQueryKey("loginTestToken", options)];

export const loginTestTokenOptions = (
  options?: Options<LoginTestTokenData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await LoginService.loginTestToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: loginTestTokenQueryKey(options),
  });
};

export const loginTestTokenMutation = (
  options?: Partial<Options<LoginTestTokenData>>,
) => {
  const mutationOptions: UseMutationOptions<
    LoginTestTokenResponse,
    AxiosError<LoginTestTokenError>,
    Options<LoginTestTokenData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await LoginService.loginTestToken({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const loginRecoverPasswordQueryKey = (
  options: Options<LoginRecoverPasswordData>,
) => [createQueryKey("loginRecoverPassword", options)];

export const loginRecoverPasswordOptions = (
  options: Options<LoginRecoverPasswordData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await LoginService.loginRecoverPassword({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: loginRecoverPasswordQueryKey(options),
  });
};

export const loginRecoverPasswordMutation = (
  options?: Partial<Options<LoginRecoverPasswordData>>,
) => {
  const mutationOptions: UseMutationOptions<
    LoginRecoverPasswordResponse,
    AxiosError<LoginRecoverPasswordError>,
    Options<LoginRecoverPasswordData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await LoginService.loginRecoverPassword({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const loginResetPasswordQueryKey = (
  options: Options<LoginResetPasswordData>,
) => [createQueryKey("loginResetPassword", options)];

export const loginResetPasswordOptions = (
  options: Options<LoginResetPasswordData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await LoginService.loginResetPassword({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: loginResetPasswordQueryKey(options),
  });
};

export const loginResetPasswordMutation = (
  options?: Partial<Options<LoginResetPasswordData>>,
) => {
  const mutationOptions: UseMutationOptions<
    LoginResetPasswordResponse,
    AxiosError<LoginResetPasswordError>,
    Options<LoginResetPasswordData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await LoginService.loginResetPassword({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const loginRecoverPasswordHtmlContentQueryKey = (
  options: Options<LoginRecoverPasswordHtmlContentData>,
) => [createQueryKey("loginRecoverPasswordHtmlContent", options)];

export const loginRecoverPasswordHtmlContentOptions = (
  options: Options<LoginRecoverPasswordHtmlContentData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await LoginService.loginRecoverPasswordHtmlContent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: loginRecoverPasswordHtmlContentQueryKey(options),
  });
};

export const loginRecoverPasswordHtmlContentMutation = (
  options?: Partial<Options<LoginRecoverPasswordHtmlContentData>>,
) => {
  const mutationOptions: UseMutationOptions<
    LoginRecoverPasswordHtmlContentResponse,
    AxiosError<LoginRecoverPasswordHtmlContentError>,
    Options<LoginRecoverPasswordHtmlContentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await LoginService.loginRecoverPasswordHtmlContent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const usersReadUsersQueryKey = (
  options?: Options<UsersReadUsersData>,
) => [createQueryKey("usersReadUsers", options)];

export const usersReadUsersOptions = (
  options?: Options<UsersReadUsersData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await UsersService.usersReadUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: usersReadUsersQueryKey(options),
  });
};

export const usersCreateUserQueryKey = (
  options: Options<UsersCreateUserData>,
) => [createQueryKey("usersCreateUser", options)];

export const usersCreateUserOptions = (
  options: Options<UsersCreateUserData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await UsersService.usersCreateUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: usersCreateUserQueryKey(options),
  });
};

export const usersCreateUserMutation = (
  options?: Partial<Options<UsersCreateUserData>>,
) => {
  const mutationOptions: UseMutationOptions<
    UsersCreateUserResponse,
    AxiosError<UsersCreateUserError>,
    Options<UsersCreateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await UsersService.usersCreateUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const usersDeleteUserMeMutation = (
  options?: Partial<Options<UsersDeleteUserMeData>>,
) => {
  const mutationOptions: UseMutationOptions<
    UsersDeleteUserMeResponse,
    AxiosError<UsersDeleteUserMeError>,
    Options<UsersDeleteUserMeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await UsersService.usersDeleteUserMe({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const usersReadUserMeQueryKey = (
  options?: Options<UsersReadUserMeData>,
) => [createQueryKey("usersReadUserMe", options)];

export const usersReadUserMeOptions = (
  options?: Options<UsersReadUserMeData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await UsersService.usersReadUserMe({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: usersReadUserMeQueryKey(options),
  });
};

export const usersUpdateUserMeMutation = (
  options?: Partial<Options<UsersUpdateUserMeData>>,
) => {
  const mutationOptions: UseMutationOptions<
    UsersUpdateUserMeResponse,
    AxiosError<UsersUpdateUserMeError>,
    Options<UsersUpdateUserMeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await UsersService.usersUpdateUserMe({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const usersUpdatePasswordMeMutation = (
  options?: Partial<Options<UsersUpdatePasswordMeData>>,
) => {
  const mutationOptions: UseMutationOptions<
    UsersUpdatePasswordMeResponse,
    AxiosError<UsersUpdatePasswordMeError>,
    Options<UsersUpdatePasswordMeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await UsersService.usersUpdatePasswordMe({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const usersRegisterUserQueryKey = (
  options: Options<UsersRegisterUserData>,
) => [createQueryKey("usersRegisterUser", options)];

export const usersRegisterUserOptions = (
  options: Options<UsersRegisterUserData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await UsersService.usersRegisterUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: usersRegisterUserQueryKey(options),
  });
};

export const usersRegisterUserMutation = (
  options?: Partial<Options<UsersRegisterUserData>>,
) => {
  const mutationOptions: UseMutationOptions<
    UsersRegisterUserResponse,
    AxiosError<UsersRegisterUserError>,
    Options<UsersRegisterUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await UsersService.usersRegisterUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const usersDeleteUserMutation = (
  options?: Partial<Options<UsersDeleteUserData>>,
) => {
  const mutationOptions: UseMutationOptions<
    UsersDeleteUserResponse,
    AxiosError<UsersDeleteUserError>,
    Options<UsersDeleteUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await UsersService.usersDeleteUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const usersReadUserByIdQueryKey = (
  options: Options<UsersReadUserByIdData>,
) => [createQueryKey("usersReadUserById", options)];

export const usersReadUserByIdOptions = (
  options: Options<UsersReadUserByIdData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await UsersService.usersReadUserById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: usersReadUserByIdQueryKey(options),
  });
};

export const usersUpdateUserMutation = (
  options?: Partial<Options<UsersUpdateUserData>>,
) => {
  const mutationOptions: UseMutationOptions<
    UsersUpdateUserResponse,
    AxiosError<UsersUpdateUserError>,
    Options<UsersUpdateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await UsersService.usersUpdateUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const utilsTestEmailQueryKey = (
  options: Options<UtilsTestEmailData>,
) => [createQueryKey("utilsTestEmail", options)];

export const utilsTestEmailOptions = (options: Options<UtilsTestEmailData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await UtilsService.utilsTestEmail({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: utilsTestEmailQueryKey(options),
  });
};

export const utilsTestEmailMutation = (
  options?: Partial<Options<UtilsTestEmailData>>,
) => {
  const mutationOptions: UseMutationOptions<
    UtilsTestEmailResponse,
    AxiosError<UtilsTestEmailError>,
    Options<UtilsTestEmailData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await UtilsService.utilsTestEmail({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const utilsHealthCheckQueryKey = (
  options?: Options<UtilsHealthCheckData>,
) => [createQueryKey("utilsHealthCheck", options)];

export const utilsHealthCheckOptions = (
  options?: Options<UtilsHealthCheckData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await UtilsService.utilsHealthCheck({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: utilsHealthCheckQueryKey(options),
  });
};

export const itemsReadItemsQueryKey = (
  options?: Options<ItemsReadItemsData>,
) => [createQueryKey("itemsReadItems", options)];

export const itemsReadItemsOptions = (
  options?: Options<ItemsReadItemsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ItemsService.itemsReadItems({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: itemsReadItemsQueryKey(options),
  });
};

export const itemsCreateItemQueryKey = (
  options: Options<ItemsCreateItemData>,
) => [createQueryKey("itemsCreateItem", options)];

export const itemsCreateItemOptions = (
  options: Options<ItemsCreateItemData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ItemsService.itemsCreateItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: itemsCreateItemQueryKey(options),
  });
};

export const itemsCreateItemMutation = (
  options?: Partial<Options<ItemsCreateItemData>>,
) => {
  const mutationOptions: UseMutationOptions<
    ItemsCreateItemResponse,
    AxiosError<ItemsCreateItemError>,
    Options<ItemsCreateItemData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ItemsService.itemsCreateItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const itemsDeleteItemMutation = (
  options?: Partial<Options<ItemsDeleteItemData>>,
) => {
  const mutationOptions: UseMutationOptions<
    ItemsDeleteItemResponse,
    AxiosError<ItemsDeleteItemError>,
    Options<ItemsDeleteItemData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ItemsService.itemsDeleteItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const itemsReadItemQueryKey = (options: Options<ItemsReadItemData>) => [
  createQueryKey("itemsReadItem", options),
];

export const itemsReadItemOptions = (options: Options<ItemsReadItemData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ItemsService.itemsReadItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: itemsReadItemQueryKey(options),
  });
};

export const itemsUpdateItemMutation = (
  options?: Partial<Options<ItemsUpdateItemData>>,
) => {
  const mutationOptions: UseMutationOptions<
    ItemsUpdateItemResponse,
    AxiosError<ItemsUpdateItemError>,
    Options<ItemsUpdateItemData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ItemsService.itemsUpdateItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const privateCreateUserQueryKey = (
  options: Options<PrivateCreateUserData>,
) => [createQueryKey("privateCreateUser", options)];

export const privateCreateUserOptions = (
  options: Options<PrivateCreateUserData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await PrivateService.privateCreateUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: privateCreateUserQueryKey(options),
  });
};

export const privateCreateUserMutation = (
  options?: Partial<Options<PrivateCreateUserData>>,
) => {
  const mutationOptions: UseMutationOptions<
    PrivateCreateUserResponse,
    AxiosError<PrivateCreateUserError>,
    Options<PrivateCreateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await PrivateService.privateCreateUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};
